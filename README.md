<h1>rust第二课</h1>
这里我就直接记录我自己对的这些概念理解
<h2>所有权</h2>
在Rust中，所有权是一种内存管理机制，它确保了在程序中不会发生内存泄漏或访问无效内存的情况。每个值都有一个拥有它的变量，这个变量被称为值的所有者。当值的所有者超出范围时(变量的生命周期结束)，Rust会确保该值被释放，以避免资源泄漏。这个概念有助于提高代码的安全性和性能。

Rust中的所有权规则包括：
<ul>
<li>移动（Move）：当将一个值赋给另一个变量时，所有权会从一个变量转移到另一个变量。这意味着新变量具有该值的所有权，原始变量不再具有值的所有权，而是进入不可用的无效状态。这有助于防止多个变量同时访问和修改同一内存位置。

<li>复制（Copy）：对于具有简单固定大小的类型（如整数、浮点数等），Rust会自动复制值，而不是移动它。也就是可以多个变量引用相同的数据而不会产生问题。

<li>借用（Borrowing）：Rust允许通过引用来借用值，而不会转移所有权。这可以是可变引用（mutable reference）或不可变引用（immutable reference）。这使得多个部分可以同时访问数据而不会引起竞态条件。

<li>生命周期（Lifetime）：Rust还涉及生命周期规则，确保引用在其所引用的数据有效的时间内。这有助于防止悬垂引用（dangling references）和其他内存安全问题。
</ul>
<b>如果函数调用时将所有权移动给函数的局部变量，函数结束之后也会释放掉值的所有权</b>

默认做复制操作的有：
<ul>
<li>所有的整数类型，比如u32,
<li>布尔类型，bool
<li>点数类型：f32, f64
<li>字符类型 char
<li>由以上类型组成的元组类型 Tuple，如（i32, i32, char）
</ul>
其它类型，默认都是做值的移动操作

<h2>引用</h2>
    引用是一种允许访问值但不获取其所有权的机制。这使得可以在不移交所有权的情况下，借用数据。Rust中的引用分为可变引用和不可变引用，分别用于指示是否允许对数据进行修改。引用的概念与指针类似，但它们遵循借用规则，这样可以在编译时保证内存安全。
<h3>不可变引用</h3>
它允许借用数据并对其进行读取操作，但不能修改数据。不可变引用可以被多次创建，且可以在同一作用域中同时存在多个不可变引用。
<ul>
<li>只读访问：可以使用不可变引用来查看数据，但不能对数据进行修改。这有助于防止数据的并发修改，从而提高代码的安全性。

<li>多重共享：多个不可变引用可以同时引用同一数据。这使得多个部分可以并发地读取数据而不会引发竞态条件。这是 Rust 的核心并发性特性之一，允许线程安全地共享只读数据。

<li>生命周期短暂：不可变引用的生命周期通常比可变引用更长，因为不可变引用不涉及数据修改，所以它们不会引起悬垂引用问题。

<li>不会引发数据竞争：由于不可变引用只允许读取数据，它们不会引发数据竞争，即使多个线程同时拥有不可变引用也是安全的。
</ul>

<h3>可变引用</h3>
它允许借用数据并对其进行读写操作。但在特定作用域中，一次只能存在一个可变引用，这是为了避免数据竞争和悬垂引用。

<ul>
<li>写访问：可变引用允许对数据进行写操作。

<li>唯一性：在特定作用域中，只能存在一个可变引用。这是为了防止数据竞争，因为多个同时修改数据的可变引用可能导致未定义行为。当一个部分持有可变引用时，其他部分不能持有任何类型的引用（不可变引用或可变引用）。

<li>生命周期检查：Rust 编译器会执行生命周期检查，以确保可变引用的生命周期在修改数据时不会引发悬垂引用问题。这有助于在编译时捕获潜在的内存安全问题。

<li>可变性标记：可变引用需要通过 &mut 关键字进行标记。例如，&mut T 表示可变引用，其中 T 是数据的类型。
</ul>